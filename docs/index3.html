<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Drag markers</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

  <link href="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.js"></script>

  <link href='https://dobatovkin.github.io/mapbox-gl-legend/docs/mapbox-gl-legend.css' rel='stylesheet' />
  <script src="https://dobatovkin.github.io/mapbox-gl-legend/docs/mapbox-gl-legend.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }

    #menu {
      position: absolute;
      background: #efefef;
      padding: 10px;
      font-family: 'Open Sans', sans-serif;
    }

    #properties-menu {
      position: absolute;

    }

    .coordinates {
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      position: absolute;
      bottom: 20px;
      left: 10px;
      padding: 5px 10px;
      margin: 0;
      font-size: 11px;
      line-height: 18px;
      border-radius: 3px;
      display: none;
    }

    .dot {
      height: 30px;
      width: 30px;
      background-color: red;
      border-radius: 50%;
      display: inline-block;
    }
  </style>
</head>

<body>

  <div id="map"></div>
  <div id="menu">
    <input id="satellite-streets-v12" type="radio" name="rtoggle" value="satellite">
    <label for="satellite-streets-v12">satellite</label>
    <input id="streets-v12" type="radio" name="rtoggle" value="streets" checked="checked">
    <label for="streets-v12">streets</label>
  </div>

  <div id="properties-menu"></div>

  <pre id="coordinates" class="coordinates"></pre>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoibWFuaW5nc2FtYmFsZSIsImEiOiJjamx3YTQya2ExNWdlM3FwM3Z1YWp2bHZrIn0.mk2emL4LkX_uwFPq7nHZsA';

    function filterProperties(raw) {
      const filtered = Object.keys(raw)
        .filter((key) => key.startsWith('string'))
        .reduce((obj, key) => {
          return {
            ...obj,
            [key]: raw[key]
          };
        }, {});
    };


    //test markers https://colorbrewer2.org/#type=qualitative&scheme=Accent&n=3 ['#7fc97f','#beaed4','#fdc086']
    var rpMarker = document.createElement('span');
    rpMarker.className = "dot";

    var marker1 = new mapboxgl.Marker({
      draggable: true,
      color: "#3a59fa"
    });

    var marker2 = new mapboxgl.Marker({
      draggable: true,
      color: "blue",
      element: rpMarker,
    });

    var marker3 = new mapboxgl.Marker({
      draggable: false,
      color: "gray",
      scale: 1
    });

    var marker4 = new mapboxgl.Marker({
      draggable: false,
      color: "green",
      scale: 0.7
    });

    var marker5 = new mapboxgl.Marker({
      draggable: false,
      color: "yellow",
      scale: 0.7
    });

    var marker6 = new mapboxgl.Marker({
      draggable: false,
      color: "",
      scale: 0.7
    });

    function onDragEnd() {
      const lngLat = marker1.getLngLat();
      const lngLat2 = marker2.getLngLat();
      const lngLat3 = marker3.getLngLat();
      window.Retool.modelUpdate({
        latitude: lngLat.lat,
        longitude: lngLat.lng,
        rp_lat: lngLat2.lat,
        rp_lon: lngLat2.lng,
        source_lat: lngLat3.lat,
        source_lon: lngLat3.lng,
        debug: map.getStyle(),
      });
    }

    const map = new mapboxgl.Map({
      container: 'map', // container ID
      style: 'mapbox://styles/mapbox/streets-v12', // style URL
      //center: [-2.81361, 36.77271], // starting position [lng, lat]
      zoom: 16, // starting zoom
      projection: 'mercator',
    });

    const layerList = document.getElementById('menu');
    const inputs = layerList.getElementsByTagName('input');

    for (const input of inputs) {
      input.onclick = (layer) => {
        const layerId = layer.target.id;
        map.setStyle('mapbox://styles/mapbox/' + layerId);
      };
    }

    var rowId;
    var featureIndex = 0;
    var addedLayers = [];
    var legendControl;

    window.Retool.subscribe(function (model) {
      if (!model) {
        return;
      }
      let boundarydata = {
        lat: [],
        lng: []
      };

      if (model.source_lon && model.source_lat) {
        marker3.setLngLat([parseFloat(model.source_lon), parseFloat(model.source_lat)]);
        marker3.addTo(map);
        boundarydata.lat.push(parseFloat(model.source_lat));
        boundarydata.lng.push(parseFloat(model.source_lon));
      }
      if (model.google_lon && model.google_lat) {
        marker4.setLngLat([parseFloat(model.google_lon), parseFloat(model.google_lat)]);
        marker4.addTo(map);
        boundarydata.lat.push(parseFloat(model.google_lat));
        boundarydata.lng.push(parseFloat(model.google_lon));
      }
      if (model.bing_lon && model.bing_lat) {
        marker5.setLngLat([parseFloat(model.bing_lon), parseFloat(model.bing_lat)]);
        marker5.addTo(map);
        boundarydata.lat.push(parseFloat(model.bing_lat));
        boundarydata.lng.push(parseFloat(model.bing_lon));
      }

      if (model.here_lon && model.here_lat) {
        marker6.setLngLat([parseFloat(model.here_lon), parseFloat(model.here_lat)]);
        marker6.addTo(map);
        boundarydata.lat.push(parseFloat(model.here_lat));
        boundarydata.lng.push(parseFloat(model.here_lon));
      }

      marker2.setLngLat([parseFloat(model.rp_lon), parseFloat(model.rp_lat)]);
      marker2.addTo(map);

      marker1.setLngLat([parseFloat(model.longitude), parseFloat(model.latitude)]);
      marker1.addTo(map);
      boundarydata.lat.push(parseFloat(model.latitude));
      boundarydata.lng.push(parseFloat(model.longitude));

      const prepGeojsonPoints = async (geojson) => {
        // check if it is a FeatureCollection
        if (geojson.type !== 'FeatureCollection') {
          throw new Error(`Entered geojson is not a "FeatureCollection"`)
        }
        // remove old legend
        map.removeControl(legendControl);
        // remove old layers & sources
        for (const layerId of Object.keys(addedLayers)) {
          if (map.getLayer(layerId)) {
            map.removeLayer(layerId);
          }
          if (map.getSource(layerId)) {
            map.removeSource(layerId);
          }
        }

        // reset feature index
        if (featureIndex === undefined) {
          featureIndex = 0;
        }

        // clear deleted layers
        addedLayers = {};

        // add new layers n sources
        await geojson.features.forEach((feature) => {
          if (feature.type === 'Feature' && feature.geometry.type === 'Point') {
            // add source and layer for every feature
            feature.properties.id = 0;
            let layerId = 'geojson-feature-' + featureIndex;
            map.addSource(layerId, {
              type: 'geojson',
              data: feature,
              generateId: true,
            });
            map.addLayer({
              id: layerId,
              type: 'circle',
              source: layerId,
              paint: {
                'circle-radius': 15,
                'circle-color': ['case',
                  ['boolean', ['feature-state', 'active'], false], '#7f0000',
                  '#000'],
              },
              metadata: {
                center: feature.geometry.coordinates,
              },
            });
            const filteredProperties = filterProperties(feature.properties);
            // add event to each layer to display popup with properties
            map.on('click', layerId, (e) => {
              const allSources = map?.getStyle().sources;
              for (const sourceId in allSources) {
                    if (allSources[sourceId].type = 'geojson') {
                        map?.removeFeatureState({
                            source: sourceId,
                      });
                  };
              }; 
              map.setFeatureState({
                source: layerId,
                id: e.features[0].id,
                }, {
                active: true
                });
            });
            
            // increment feature index and append added layer to obj
            featureIndex++;
            addedLayers[layerId] = feature.properties['tofix:category'];
          }
        });
        legendControl = new MapboxLegendControl(addedLayers, {
          showDefault: true,
          showCheckbox: true,
          onlyRendered: false,
          reverseOrder: true,
          zoomOnClick: true,
        });
        map.addControl(legendControl, 'top-right');
      };


      if (rowId !== model.row_id) {
        var bbox = [
          [Math.min(...boundarydata.lng), Math.min(...boundarydata.lat)],
          [Math.max(...boundarydata.lng), Math.max(...boundarydata.lat)]
        ];
        map.fitBounds(bbox, {
          padding: 100,
          speed: 10,
          maxZoom: 18.5
        });
        map.once('idle', () => {
          prepGeojsonPoints(model.featureCollection);
        });
        rowId = model.row_id;
        boundarydata = {
          lat: [],
          lng: []
        };
      }
    });

    marker1.on('dragend', onDragEnd);
    marker2.on('dragend', onDragEnd);
    map.on('contextmenu', (e) => {
      marker1.setLngLat(e.lngLat);
      marker2.setLngLat(e.lngLat);
      onDragEnd();
    });
  </script>

</body>

</html>